package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	_ "qualification/docs" // docs are generated by Swag CLI, you have to import it.
	internalES "qualification/internal/elastic"
	"qualification/internal/jaeger"
	"qualification/internal/usecase"
	blModel "qualification/internal/usecase/model"

	"github.com/getsentry/raven-go"
	"github.com/gorilla/mux"
	"github.com/jackc/pgx/v4/log/logrusadapter"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
	httpSwagger "github.com/swaggo/http-swagger"
	"go.opentelemetry.io/otel/trace"
)

type (
	App struct {
		Router *mux.Router
		DB     *pgxpool.Pool
		ES     internalES.ES
	}
)

// Run
// @title           Swagger Example API
// @version         1.0
// @description     This is a sample server celler server.
func (a *App) Run(withPgxLog, withES bool) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	tp, err := jaeger.InitTracer("http://localhost:14268/api/traces", "products")
	if err != nil {
		log.Println(fmt.Sprintf("Unable to connect to jaeger: %v\n", err))
		os.Exit(1)
	}

	// Cleanly shutdown and flush telemetry when the application exits.
	defer func(ctx context.Context) {
		// Do not make the application hang when it is shutdown.
		ctx, cancel := context.WithTimeout(ctx, time.Second*5)
		defer cancel()
		if err := tp.Shutdown(ctx); err != nil {
			log.Fatal(err)
		}
	}(ctx)

	conn, err := pgxpool.Connect(ctx, "postgres://postgres:postgres@0.0.0.0:5455/postgres")
	if err != nil {
		log.Println(fmt.Sprintf("Unable to connect to database: %v\n", err))
		os.Exit(1)
	}

	if withES {
		esClient, err := elastic.NewClient(elastic.SetURL("http://localhost:9200"),
			elastic.SetSniff(false),
			elastic.SetHealthcheck(false))
		if err != nil {
			fmt.Println(fmt.Errorf("elastic conn err: %w", err))
			os.Exit(0)
		}

		fmt.Println("ES initialized...")

		a.ES = internalES.NewEsClient(esClient)
	}

	if withPgxLog {
		config, err := pgxpool.ParseConfig("postgres://postgres:postgres@0.0.0.0:5455/postgres")
		if err != nil {
			log.Println(fmt.Sprintf("Unable to parse config: %v\n", err))
			os.Exit(1)
		}
		logrusLogger := &logrus.Logger{
			Out:          os.Stderr,
			Formatter:    new(logrus.JSONFormatter),
			Level:        logrus.DebugLevel,
			ExitFunc:     os.Exit,
			ReportCaller: false,
		}

		config.ConnConfig.Logger = logrusadapter.NewLogger(logrusLogger)
		conn, err = pgxpool.ConnectConfig(context.Background(), config)
		if err != nil {
			log.Println(fmt.Sprintf("Unable to connect to database: %v\n", err))
			os.Exit(1)
		}
	}

	raven.SetDSN("https://a236b8d2d3cac0e05afe511c2192fa33@o4506172993175552.ingest.sentry.io/4506173020176384")

	a.DB = conn
	a.Router = mux.NewRouter()

	a.Router.HandleFunc("/products", a.GetProducts).Methods("GET")
	a.Router.HandleFunc("/product", a.CreateProduct).Methods("POST")
	a.Router.HandleFunc("/product/{id}", a.GetProduct).Methods("GET")
	a.Router.HandleFunc("/product", a.SearchProduct).Methods("GET")

	a.Router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

	fmt.Println("http://localhost:8088/swagger/index.html")
	log.Fatal(http.ListenAndServe(":8088", a.Router))
}

// GetProducts
// @Title 		Get Products
// @Description Get All products
// @Success 	200 		{object} blModel.Product
// @Router 		/products 	[get]
func (a *App) GetProducts(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	ctx, span := jaeger.NewSpan(r.Context(), "http GetProducts")
	defer span.End()

	res, err := usecase.GetProducts(ctx, a.DB)
	if err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Internal error"}, span, err)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(res)
}

// CreateProduct
// @Title        Create product
// @Description  Method to create product
// @Param        input    body      blModel.Product  true  "Body"
// @Success      200      {object}  string
// @Router       /product [post].
func (a *App) CreateProduct(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	ctx, span := jaeger.NewSpan(r.Context(), "http CreateProduct")
	defer span.End()

	var req blModel.Product

	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&req); err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Invalid request payload"}, span, err)
		return
	}
	defer r.Body.Close()

	jsonReq, _ := json.Marshal(req)
	jaeger.AddAttributes(span, "CreateProduct req", string(jsonReq))

	if err := usecase.CreateProduct(ctx, a.DB, req); err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": err.Error()}, span, err)
		return
	}

	if a.ES != nil {
		if err := a.ES.CreateProductIndex(context.Background(), req); err != nil {
			respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": err.Error()}, span, err)
			return
		}
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode("ok")
}

// GetProduct
// @Title        Get specific product
// @Description  Method to get product
// @Param        id    			path      int  true  "product id"
// @Success      200      		{object}  blModel.Product
// @Router       /product/{id} 	[get].
func (a *App) GetProduct(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	ctx, span := jaeger.NewSpan(r.Context(), "http GetProduct")
	defer span.End()

	jaeger.AddAttributes(span, "GetProduct req", mux.Vars(r)["id"])

	productID, err := strconv.Atoi(mux.Vars(r)["id"])
	if err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Invalid product ID"}, span, err)
		return
	}

	product, err := usecase.GetProduct(ctx, a.DB, productID)
	if err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Internal error"}, span, err)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(product)
}

// SearchProduct
// @Title        Search product by name
// @Description  Method to search product
// @Param        name    			query      string  true  "product name"
// @Success      200      		{object}  blModel.Product
// @Router       /product 	[get].
func (a *App) SearchProduct(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	products := make([]blModel.Product, 0, 10)

	if a.ES != nil {
		products = a.ES.SearchDoc(context.Background(), r.URL.Query().Get("name"))
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(products)
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}, span trace.Span, err error) {
	// jaeger
	jaeger.RecordError(span, err)

	// sentry
	raven.CaptureError(err, nil)

	response, _ := json.Marshal(payload)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(response)
}
