package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"

	_ "qualification/docs" // docs are generated by Swag CLI, you have to import it.
	internalES "qualification/internal/elastic"
	"qualification/internal/usecase"
	blModel "qualification/internal/usecase/model"

	"github.com/gorilla/mux"
	"github.com/jackc/pgx/v4/log/logrusadapter"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/olivere/elastic/v7"
	"github.com/sirupsen/logrus"
	httpSwagger "github.com/swaggo/http-swagger"
)

type (
	App struct {
		Router *mux.Router
		DB     *pgxpool.Pool
		ES     internalES.ES
	}
)

// Run
// @title           Swagger Example API
// @version         1.0
// @description     This is a sample server celler server.
func (a *App) Run(withPgxLog, withES bool) {
	conn, err := pgxpool.Connect(context.Background(), "postgres://postgres:postgres@0.0.0.0:5455/postgres")
	if err != nil {
		fmt.Sprintf("Unable to connect to database: %v\n", err)
	}

	if withES {
		esClient, err := elastic.NewClient(elastic.SetURL("http://localhost:9200"),
			elastic.SetSniff(false),
			elastic.SetHealthcheck(false))
		if err != nil {
			fmt.Println(fmt.Errorf("elastic conn err: %w", err))
			os.Exit(0)
		}

		fmt.Println("ES initialized...")

		a.ES = internalES.NewEsClient(esClient)
	}

	if withPgxLog {
		config, err := pgxpool.ParseConfig("postgres://postgres:postgres@0.0.0.0:5455/postgres")
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to parse config: %v\n", err)
			os.Exit(1)
		}
		logrusLogger := &logrus.Logger{
			Out:          os.Stderr,
			Formatter:    new(logrus.JSONFormatter),
			Level:        logrus.DebugLevel,
			ExitFunc:     os.Exit,
			ReportCaller: false,
		}

		config.ConnConfig.Logger = logrusadapter.NewLogger(logrusLogger)
		conn, err = pgxpool.ConnectConfig(context.Background(), config)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
			os.Exit(1)
		}
	}

	a.DB = conn
	a.Router = mux.NewRouter()

	a.Router.HandleFunc("/products", a.GetProducts).Methods("GET")
	a.Router.HandleFunc("/product", a.CreateProduct).Methods("POST")
	a.Router.HandleFunc("/product/{id}", a.GetProduct).Methods("GET")
	a.Router.HandleFunc("/product", a.SearchProduct).Methods("GET")

	a.Router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

	fmt.Println("http://localhost:8088/swagger/index.html")
	log.Fatal(http.ListenAndServe(":8088", a.Router))
}

// GetProducts
// @Title 		Get Products
// @Description Get All products
// @Success 	200 		{object} blModel.Product
// @Router 		/products 	[get]
func (a *App) GetProducts(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	res, err := usecase.GetProducts(context.Background(), a.DB)
	if err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Internal error"})
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(res)
}

// CreateProduct
// @Title        Create product
// @Description  Method to create product
// @Param        input    body      blModel.Product  true  "Body"
// @Success      200      {object}  string
// @Router       /product [post].
func (a *App) CreateProduct(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	var req blModel.Product

	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&req); err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Invalid request payload"})
		return
	}
	defer r.Body.Close()

	if err := usecase.CreateProduct(context.Background(), a.DB, req); err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": err.Error()})
		return
	}

	if a.ES != nil {
		if err := a.ES.CreateProductIndex(context.Background(), req); err != nil {
			respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": err.Error()})
			return
		}
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode("ok")
}

// GetProduct
// @Title        Get specific product
// @Description  Method to get product
// @Param        id    			path      int  true  "product id"
// @Success      200      		{object}  blModel.Product
// @Router       /product/{id} 	[get].
func (a *App) GetProduct(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	productID, err := strconv.Atoi(mux.Vars(r)["id"])
	if err != nil {
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Invalid product ID"})
		return
	}

	product, err := usecase.GetProduct(context.Background(), a.DB, productID)
	if err != nil {
		fmt.Println(err)
		respondWithJSON(w, http.StatusBadRequest, map[string]string{"error": "Internal error"})
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(product)
}

// SearchProduct
// @Title        Search product by name
// @Description  Method to search product
// @Param        name    			query      string  true  "product name"
// @Success      200      		{object}  blModel.Product
// @Router       /product 	[get].
func (a *App) SearchProduct(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	products := make([]blModel.Product, 0, 10)

	if a.ES != nil {
		products = a.ES.SearchDoc(context.Background(), r.URL.Query().Get("name"))
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(products)
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	response, _ := json.Marshal(payload)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(response)
}
